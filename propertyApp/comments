app.py





#import pandas as pd
#from Property import Property
# @st.cache
# def load_data(file_path):
#     return pd.read_csv(file_path, delimiter='|')
#
#
# # Function to convert DataFrame rows to Property objects
# def create_property_objects(dataframe):
#     property_list = []
#     for _, row in dataframe.iterrows():
#         full_address = f"{row['street']}, {row['district']}, {row['city']}"
#         property_obj = Property(
#             title=row['title'],
#             area=row['area'],
#             number_of_rooms=row['number_of_rooms'],
#             floor=row['floor'],
#             price_for_m2_in_PLN=row['price_for_m2_in_PLN'],
#             address=full_address,
#             year_of_creation=row['year_of_creation'],
#             type_of_market=row['type_of_market'],
#             type_of_building=row['type_of_building'],
#             parking=row['parking'],
#             internet=row['internet'],
#             basement=row['basement'],
#             balcony=row['balcony'],
#             garden=row['garden'],
#             terrace=row['terrace'],
#             elevator=row['elevator'],
#         )
#         property_list.append(property_obj)
#     return property_list
#
#
# # Load CSV data into a DataFrame
# data = load_data('./cleaned_dataset_without_na.csv')
#
# # Display the CSV data as a table in Streamlit
# st.write("Properties Data (as table):")
# st.dataframe(data)
#
# # Convert rows to Property objects
# properties = create_property_objects(data)
#
# # Display each Property object
# st.write("Properties (as objects):")
# for prop in properties:
#     st.write(str(prop))  # Calls the __str__ method of the Property class














app.py
# import streamlit as st
# import Property
# from DistrictNames import DISTRICTS
# import requests
#
# API_URL = "http://127.0.0.1:8000"
# p=0
# # Create an instance of the User class with default values
# property = Property.Property()
# st.title("Property price predictions")
# # Streamlit app
# # Dynamically update district options when the city changes
# c = st.radio("City", options=['Gdynia', 'Gdańsk', 'Sopot'])
#
# if c != 'Gdańsk':
#     city = c.lower()
# else:
#     city = 'gdansk'
#
# model = st.radio("Chose model", options=['Gradient Boosting', 'Random Forest', 'XGB'])
# # Use Streamlit form for property details
# with st.form("property_form"):
#     st.header("Property details form")
#
#     # Display widgets for each attribute
#     district = st.selectbox("District", options=DISTRICTS[city])
#     area = st.number_input("Area [sqm]", value=property.area, min_value=0.0, step=0.5)
#     number_of_rooms = st.slider("Number of rooms", min_value=1, max_value=10, value=property.number_of_rooms)
#     floor = st.radio("Floor", options=['0', '1-3', '4-7', '8+'], index=1 if property.floor == '1-3' else 0)
#     year_of_creation = st.number_input("Year of creation", value=property.year_of_creation, min_value=1900,
#                                        max_value=2023, step=10)
#     type_of_market = st.selectbox("Type of market", ["primary", "secondary"])
#     type_of_building = st.selectbox("Type of building", ["Apartment", "House"])
#     # Checkbox widgets for boolean attributes
#     parking = st.checkbox("parking", value=property.parking)
#     internet = st.checkbox("internet", value=property.internet)
#     basement = st.checkbox("basement", value=property.basement)
#     balcony = st.checkbox("balcony", value=property.balcony)
#     garden = st.checkbox("garden", value=property.garden)
#     terrace = st.checkbox("terrace", value=property.terrace)
#     elevator = st.checkbox("elevator", value=property.elevator)
#
#     # Submit button to apply changes
#     submitted = st.form_submit_button("Submit")
#
#     if submitted:
#         # Update property object if form is submitted
#         property.update(
#             area=area,
#             number_of_rooms=number_of_rooms,
#             floor=floor,
#             city=city,
#             district=district.lower(),
#             year_of_creation=year_of_creation,
#             type_of_market=type_of_market,
#             type_of_building=type_of_building,
#             parking=parking,
#             internet=internet,
#             basement=basement,
#             balcony=balcony,
#             garden=garden,
#             terrace=terrace,
#             elevator=elevator,
#
#         )
#         st.success("Property details updated successfully!")
#         st.write(property)
#         property_data = {
#             "model": model,
#             "area": area,
#             "number_of_rooms": number_of_rooms,
#             "floor": floor,
#             "type_of_market": type_of_market,
#             "parking": parking,
#             "elevator": elevator,
#             "year_of_creation": year_of_creation,
#             "internet": internet,
#             "type_of_building": type_of_building,
#             "basement": basement,
#             "balcony": balcony,
#             "garden": garden,
#             "terrace": terrace,
#             "district": district,
#             "city": city
#         }
#
#         # Wysłanie żądania do serwera
#         try:
#             response = requests.post(f"{API_URL}/predict-price/", json=property_data)
#             if response.status_code == 200:
#                 prediction = response.json()
#                 st.success(f"Estimated Price: {prediction['estimated_price']:.2f} PLN")
#                 price = prediction['estimated_price']
#                 p=1
#             else:
#                 st.error(f"Error: {response.status_code}, {response.text}")
#         except Exception as e:
#             st.error(f"Connection Error: {e}")
# if p==1:
#     st.title(f"Estimated Price: {price:.2f}  PLN")
#     print(price)

















Property.py

class Property:
    def __init__(self, title, area, number_of_rooms, floor, price_for_m2_in_PLN,
                 address, year_of_creation, type_of_market, type_of_building,
                 parking, internet, basement, balcony, garden, terrace, elevator):
        self.title = title
        self.area = area
        self.number_of_rooms = number_of_rooms
        self.floor = floor
        self.price_for_m2_in_PLN = price_for_m2_in_PLN
        self.address = address
        self.year_of_creation = year_of_creation
        self.type_of_market = type_of_market
        self.type_of_building = type_of_building
        self.parking = parking
        self.internet = internet
        self.basement = basement
        self.balcony = balcony
        self.garden = garden
        self.terrace = terrace
        self.elevator = elevator

    def __str__(self):
        return f"{self.title} - {self.address}"















Server.py
# from fastapi import FastAPI
# from pydantic import BaseModel
# import random
# import joblib
# import mapbox
# import pandas as pd
#
# # import sklearn
# # import learn
# # import numpy as np
#
# app = FastAPI()
#
#
# class PropertyInput(BaseModel):
#     model: str
#     area: float
#     number_of_rooms: int
#     floor: str
#     type_of_market: str
#     parking: bool
#     elevator: bool
#     year_of_creation: int
#     internet: bool
#     type_of_building: str
#     basement: bool
#     balcony: bool
#     garden: bool
#     terrace: bool
#     district: str
#     city: str
#
#
# # Endpoint API do przetwarzania danych
# @app.post("/predict-price/")
# async def predict_price(property: PropertyInput):
#     print(property)
#
#     ACCESS_TOKEN = 'pk.eyJ1Ijoia3J6eWRvbWEiLCJhIjoiY2x6cXVnajM3MXFxZTJscXdzZW8wZDI5eSJ9.72R-bCPXUFTSAqp7sY1BHw'
#     geocoder = mapbox.Geocoder(access_token=ACCESS_TOKEN)
#
#     # wyszukiwanie estymacji i innych danych
#     # tutaj muszą być podłączone modele
#
#     if property.model == "Gradient Boosting":
#         estimated_price = random.uniform(200_000, 1_000_000)
#     elif property.model == "Random Forest":
#         model = joblib.load('random_forest_model.pkl')
#         preprocessor = joblib.load('preprocessor.pkl')
#     elif property.model == "XGB":
#         estimated_price = random.uniform(200_000, 1_000_000)
#     else:
#         estimated_price = 10
#
#     if property.model == "Random Forest":
#         res = geocoder.forward(f'{property.city}+" "+ {property.district}')
#         coordinates = res.geojson()['features'][0]['geometry']['coordinates']
#         print(coordinates)
#         column_names = [
#             "area", "number_of_rooms", "floor", "type_of_market", "parking",
#             "elevator", "year_of_creation", "internet", "type_of_building",
#             "basement", "balcony", "garden", "terrace", "district",
#             "city", "latitude", "longtitude"
#         ]
#         row = [property.area, property.number_of_rooms, property.floor, property.type_of_market, property.parking,
#                property.elevator, property.year_of_creation, property.internet, property.type_of_building,
#                property.basement,
#                property.balcony, property.garden, property.terrace, property.district, property.city, coordinates[1],
#                coordinates[0]
#                ]
#         row_df = pd.DataFrame([row], columns=column_names)
#         row_preprocessed = preprocessor.transform(row_df)
#         estimated_price = model.predict(row_preprocessed)[0]
#     return {"estimated_price": float(estimated_price * property.area)}
#
#
# @app.get("/")
# def read_root():
#     return {"message": "Server is running"}


